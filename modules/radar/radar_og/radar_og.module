<?php
/**
 * @file
 * Code for the Radar Groups feature.
 */

include_once 'radar_og.features.inc';

/**
 * Implements hook_ctools_plugin_directory().
 */
function radar_og_ctools_plugin_directory($module, $plugin) {
  if ($module == 'entityreference' || $module == 'ctools') {
    return "plugins/$module/$plugin";
  }
}

/**
 * Implements hook_modules_enabled().
 *
 * Make sure the og access fields exist when og_access is enabled.
 */
function radar_og_modules_enabled($modules) {
  if (in_array('og_access', $modules)) {
    features_revert(array('radar_og' => array('field_base')));
    features_revert(array('radar_og' => array('field_instance')));
  }
}

/**
 * Implements hook_entity_view().
 */
function radar_og_entity_view($entity, $type, $view_mode, $langcode) {
  // Set a breadcrumb for nodes in groups. We currently assume that
  // nodes are groups.
  if ($view_mode == 'full' && !empty($entity->og_group_ref[LANGUAGE_NONE][0]['target_id']) && $type != 'user') {
    $breadcrumb = array();
    $breadcrumb[] = l(t('Home'), NULL);
    $breadcrumb[] = l(t('Groups'), 'groups');
    $group = node_load($entity->og_group_ref[LANGUAGE_NONE][0]['target_id']);
    if (node_access('view', $group)) {
      $breadcrumb[] = l($group->title, 'node/' . $group->nid);
    }
    drupal_set_breadcrumb($breadcrumb);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alter the privacy settings fields.
 */
function radar_og_form_node_form_alter(&$form, &$form_state) {
  $groups = og_get_all_group_bundle();

  if (isset($groups['node']) && in_array($form_state['node']->type, array_keys($groups['node']))) {
    // The group privacy settings are not required.
    $form['field_og_subscribe_settings'][LANGUAGE_NONE]['#required'] = FALSE;

    if (module_exists('og_access')) {
      // Display private content checkbox only when "Joining requires approval"
      // is selected.
      $form['field_og_access_default_value']['#states'] = array(
        'visible' => array(
          ':input[name="field_og_subscribe_settings[' . LANGUAGE_NONE . ']"]' => array('value' => 'approval'),
        ),
      );

      $form['#after_build'] = array('radar_og_form_group_node_after_build');
    }

    $form['#attached']['css'][] = drupal_get_path('module', 'radar_og') . '/css/radar_og.css';

    // The group access is set on radar_og_node_presave().
    $form['group_access'][LANGUAGE_NONE]['#required'] = FALSE;
    $form['group_access']['#access'] = FALSE;
  }
}

/**
 * After build callback for the group node form.
 *
 * Display the private content checkbox inside the privacy settings field.
 * Only makes sense when og_access is on.
 */
function radar_og_form_group_node_after_build($form, $form_state) {
  $form['field_og_subscribe_settings'][LANGUAGE_NONE]['approval']['#suffix'] = render($form['field_og_access_default_value']);

  return $form;
}

/**
 * Update the group permission field.
 *
 * @param $role
 *   The OG role object of which the permissions are being changed.
 * @param $permissions
 *   The anonymous user permissions of the group.
 *
function _radar_og_update_group_permissions($role, $permissions) {
  $updated_roles = &drupal_static(__FUNCTION__);
  if (!empty($updated_roles[$role->rid])) {
    // Avoid updating a group subscription twice on the same request.
    return;
  }

  if (!empty($permissions['subscribe without approval'])) {
    $subscribe_type = 'anyone';
  }
  elseif (!empty($permissions['subscribe'])) {
    $subscribe_type = 'approval';
  }
  else {
    $subscribe_type = 'invitation';
  }

  $wrapper = entity_metadata_wrapper($role->group_type, $role->gid);
  if ($wrapper->field_og_subscribe_settings->value() != $subscribe_type) {
    // Mark that the group's permissions were already handled on this request,
    // to avoid saving the group entity more than once.
    $updated_roles[$role->rid] = TRUE;

    $wrapper->field_og_subscribe_settings->set($subscribe_type);
    $wrapper->save();
  }
}

/**
 * Implements hook_menu_alter().
 */
function radar_og_menu_alter(&$items) {
  // Provide a more informative title.
  if (isset($items['node/%/group'])) {
    $items['node/%/group']['title'] = t('Administer group');
  }
}

/*
 * Implements hook_menu
 * Used with radar_og_help and the radar groups update view to turn off
 * the warning message to update groups
 */
function radar_og_menu() {
  $items['admin/content/groups/update/toggle'] = array(
    'title' => 'Toggle Groups Update',
    'page callback' => 'radar_og_update_toggle',
    'access arguments' => array('edit any group content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/*
 * Ajax callback page to toggle the group update status to off
 * See https://drupal.org/node/2059857 for more information
 */
function radar_og_update_toggle() {
  variable_set('radar_og_needs_update', FALSE);
  return TRUE;
}

/**
 * Implements hook_block_info().
 */
function radar_og_block_info() {
  $blocks['radar_og_create_group'] = array(
    'info' => t('"Create a group" call to action'),
    'cache' => DRUPAL_NO_CACHE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function radar_og_block_view() {
  $block['subject'] = '';
  if (node_access('create', 'group')) {
    $block['content'] = l(t('Create a group'), 'node/add/group');
  }
  else {
    $block['content'] = '';
  }
  return $block;
}

/**
 * Implements hook_features_pipe_alter().
 */
function radar_og_features_pipe_alter(&$pipe, $data, $export) {
  // Prevent Radar Groups related fields from being piped in features
  // when a content type includes those fields.
  if (!empty($pipe['field_instance'])) {
    foreach ($pipe['field_instance'] as $delta => $value) {
      $args = explode('-', $value);
      $field_name = $args[2];
      $excluded_fields = array('og_group_ref', 'og_group_request', 'field_og_access_default_value',
        'field_og_subscribe_settings', 'og_roles_permissions', 'group_access', 'field_group_logo', 'group_group', 'body');
      if (in_array($field_name, $excluded_fields)) {
        unset($pipe['field_instance'][$delta]);
      }
    }
  }
  if (!empty($pipe['field_base'])) {
    foreach ($pipe['field_base'] as $delta => $value) {
      if ($delta == 'og_group_ref') {
        unset($pipe['field_base'][$delta]);
      }
    }
  }
}

/**
 * Implements hook_radar_entity_integration().
 */
function radar_og_radar_entity_integration() {
  return array(
    'node' => array(
      'group' => array(
        'is_group_content' => FALSE,
        'is_group' => TRUE,
        'exclude_radar_follow' => TRUE,
      ),
    ),
  );
}

/**
 *
 */
function radar_og_group_contributors_count_topics($group) {
  // Format the count of contributors.
  $output = '';
  $view = views_get_view('radar_contributors_group');
  if (!empty($view)) {
    $view->set_display('panel_pane_1');
    $view->set_arguments(array($group->nid));
    $view->get_total_rows = TRUE;
    $view->execute();
    // If there are no contributors with avatars, return an empty string
    // rather than displaying '0 contributors'.
    if (empty($view->total_rows)) {
      return '';
    }
    $contributors_count = $view->total_rows;
    $output .= l(format_plural($contributors_count, '1 contributor', '@count contributors'), 'node/' . $group->nid . '/contributors');
  }
  // Format the list of topics:
  if (!empty($group->field_topics[LANGUAGE_NONE])) {
    foreach ($group->field_topics[LANGUAGE_NONE] as $item) {
      $tids[] = $item['tid'];
    }
    $topics = taxonomy_term_load_multiple($tids);
    $topics_text = ' discussing the @topics ';
    $t_args = array('@topics' => format_plural(count($topics), 'topic', 'topics'));
    foreach ($topics as $topic) {
      $topics_text .= '!topic-' . $topic->tid;
      if ($topic == end($topics)) {
        $topics_text .= '.';
      }
      else {
        $topics_text .= ', ';
      }
      $t_args['!topic-' . $topic->tid] = l(t($topic->name), 'taxonomy/term/' . $topic->tid);
    }
    $output .= t($topics_text, $t_args);
  }
  return $output;
}

/* set radar_Groups form alter to happen after views bulk operations */
function radar_og_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'form_alter') {
    $group = $implementations['radar_og'];
    unset($implementations['radar_og']);
    $implementations['radar_og'] = $group;
  }
}

/**
 * Implements hook_form_alter().
 */
function radar_og_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'views_exposed_form' && strstr($form['#id'], 'views-exposed-form-radar-groups-directory')) {
    $form['groups-keys']['#attributes'] = array(
      'placeholder' => t('Separate keywords with commas'),
    );
  }
  if ((strstr($form_id, 'views_form_radar_group_moderation_page'))) {
    $form['select']['action::views_bulk_operations_delete_item']['#weight'] = 9;
  }
  if ($form_id == 'group_node_form' && is_null($form['nid']['#value'])) {
    $form['actions']['submit']['#submit'][] = 'radar_og_group_submission_message';
  }
  // Redirect the user back to the group homepage after submitting
  // a node within a group.
  if (isset($form['#node']) && substr($form_id, -10) == '_node_form') {
    // Hide the "Group content visibility" field to simplify the node form.
    if (!empty($form['group_content_access']['#access'])) {
      $form['group_content_access']['#access'] = FALSE;
    }
    // Set a human-friendly page title.
    if (empty($form['#node']->nid)) {
      $types = node_type_get_types();
      $type = $form['#node']->type;
      // Use 'a' or 'an' appropriately.
      $vowels = array('a', 'e', 'i', 'o', 'u');
      $verb = strtolower(in_array($type[0], $vowels)) ? 'Create an' : 'Create a';
      drupal_set_title(t("$verb @name", array('@name' => $types[$type]->name)), PASS_THROUGH);
    }
    // Customizations to the node form for entitites that are group content.
    $group_content_entity_types = radar_og_get_group_content_entity_types();
    if (isset($group_content_entity_types['node'][$form['#node']->type])) {
      $form['actions']['submit']['#submit'][] = 'radar_og_node_in_group_submit';
    }
  }
/*  // Hide internal fields that the user should not be able to edit directly.
  if ($form_id == 'edit_profile_user_profile_form' || substr($form_id, -10) === '_node_form') {
    $internal_fields = array('field_unread_invitations', 'field_unread_messages', 'user_trusted_contacts', 'og_user_group_ref', 'group_access');
    foreach ($internal_fields as $field_name) {
      if(isset($form[$field_name])) {
        $form[$field_name]['#access'] = FALSE;
      }
    }
  }
*/
}

/**
 * Submit handler called if the form is for a node enabled as group content.
 */
function radar_og_node_in_group_submit(&$form, &$form_state) {
  if (isset($form_state['values']['og_group_ref'][LANGUAGE_NONE][0])) {
    $group = $form_state['values']['og_group_ref'][LANGUAGE_NONE][0]['target_id'];
    $form_state['redirect'] = 'node/' . $group;
  }
}

/**
 * Implements hook_system_info_alter().
 */
function radar_og_system_info_alter(&$info, $file, $type) {
  // Radar Groups dynamically adds the og_group_ref field to
  // content types that request it by altering the
  // radar_og_entity_types variable.
  // We must add a corresponding line for each field instance
  // to radar_og.info so that Features is aware of the instance
  // and can successfully revert the field_instance component back
  // to its default state.
  if ($file->name == 'radar_og') {
    $group_bundles = og_get_all_group_bundle();
    if (!empty($group_bundles['node'])) {
      foreach ($group_bundles['node'] as $bundle => $name) {
        // These field instances should be added to groups regardless of
        // whether og_access.module is enabled.
        $info['features']['field_instance'][] = "node-$bundle-field_og_access_default_value";
        $info['features']['field_instance'][] = "node-$bundle-field_og_subscribe_settings";
        $info['features']['field_instance'][] = "node-$bundle-og_roles_permissions";
        $info['features']['field_instance'][] = "node-$bundle-body";
        $info['features']['field_instance'][] = "node-$bundle-group_group";

        // These fields are only necessary when og_access.module is enabled.
        $info['features']['field_instance'][] = "node-$bundle-group_access";
        $info['features']['field_instance'][] = "node-$bundle-field_group_logo";

        // Add default strongarm settings.
        $info['features']['variable'][] = "field_bundle_settings_node__$bundle";
      }
    }
    $group_content_entity_types = radar_og_get_group_content_entity_types();
    if (!empty($group_content_entity_types)) {
      foreach ($group_content_entity_types as $entity_type => $bundles) {
        foreach (array_keys($bundles) as $bundle) {
          $info['features']['field_group'][] = "group_groups|$entity_type|$bundle|form";
          $info['features']['field_instance'][] = "$entity_type-$bundle-og_group_ref";
          $info['features']['field_instance'][] = "$entity_type-$bundle-og_group_request";
          $info['features']['field_instance'][] = "$entity_type-$bundle-group_content_access";
        }
      }
    }

    // Radar specific group variables.
    $radar_og = radar_og_get_group_types();
    if (isset($radar_og['node'])) {
      foreach ($radar_og['node'] as $bundle => $group_info) {
        $info['features']['variable'][] = "node_options_$bundle";
        $info['features']['variable'][] = "node_preview_$bundle";
        $info['features']['variable'][] = "node_submitted_$bundle";
        $info['features']['variable'][] = "og_group_manager_default_rids_node_$bundle";
      }
    }
  }
}

/**
 * Implements hook_default_message_type_alter().
 */
function radar_og_default_message_type_alter(&$defaults) {
  foreach (array('radar_activity_streams_comment_created', 'radar_activity_streams_node_created') as $name) {
    if (!empty($defaults[$name])) {
      $defaults[$name]->message_text[LANGUAGE_NONE][2] = radar_og_message_partial_default();
    }
  }
}

/**
 * Implements of hook_token_info().
 */
function radar_og_token_info() {
  $types = array();
  $tokens = array();

  // Radar Groups tokens.
  $types['radar-groups'] = array(
    'name' => t('Radar Groups'),
    'description' => t('Tokens related to the Groups functionality in Drupal Radar.'),
    'needs-data' => 'node',
  );
  $tokens['radar-groups']['in-groups-text'] = array(
    'name' => t('"In groups" text'),
    'description' => t('The text (starting with "in the groups") indicating which groups a peice of content belongs to.'),
  );
  $tokens['node']['radar-groups-group-contributors-count-topics'] = array(
    'name' => t('Radar Groups: Group contributor count and topics'),
    'description' => t('Displays text showing the number of contributors and the topics associated with a group node.'),
  );
  return array(
    'types' => $types,
    'tokens' => $tokens,
  );
}


/**
 * Implements hook_tokens().
 */
function radar_og_tokens($type, $tokens, $data = array(), $options = array()) {
  $replacements = array();
  if ($type == 'node' && !empty($data['node'])) {
    $group = $data['node'];

    foreach ($tokens as $name => $original) {
      if ($name == 'radar-groups-group-contributors-count-topics') {
        $replacements[$original] = radar_og_group_contributors_count_topics($group);
        return $replacements;
      }
    }
  }
  if ($type == 'radar-groups') {
    if (!empty($tokens['in-groups-text'])) {
      // Build a list of groups associated with this message.
      $text = '';
      $target_nids = array();
      $related_groups = array();
      $related_gids = array();

      // First, build an array of target nodes associated with the message.
      foreach ($data['message']->field_target_nodes[LANGUAGE_NONE] as $key => $value) {
        $target_nids[] = $value['target_id'];
      }
      // If there are no target nodes, the in-groups-text token should be empty.
      if (empty($target_nids)) {
        $replacements['[radar-groups:in-groups-text]'] = $text;
        return $replacements;
      }
      // Build a list of groups associated with the target nodes.
      // For now, we assume that the group type is node.
      foreach ($target_nids as $key => $nid) {
        $og_memberships_this_target = og_get_entity_groups('node', $nid);
        if (!empty($og_memberships_this_target['node'])) {
          $og_memberships_this_target = $og_memberships_this_target['node'];
          foreach ($og_memberships_this_target as $membership_id => $gid) {
            $related_gids[] = $gid;
          }
        }
      }
      // If no groups are associated with any of the targett nodes,
      // then we have no "in the groups" text.
      if (empty($related_gids)) {
        $replacements['[radar-groups:in-groups-text]'] = '';
        return $replacements;
      }

      $related_groups = entity_load('node', $related_gids);
      // Key the array of groups in a predictable way.
      $related_groups = array_values($related_groups);
      // Generate the appropriate text depending on the number of groups
      // associated with the message:
      $replacements['[radar-groups:in-groups-text]'] = radar_og_related_groups_text($related_groups);
      return $replacements;
    }
  }
}

function radar_og_message_partial_default() {
  $partial = array(
    'value' => '[radar-groups:in-groups-text]',
    'format' => 'full_html',
    'safe_value' => '[radar-groups:in-groups-text]',
  );
  return $partial;
}

/**
 * Build the related-groups text for nodes.
 *
 * @param $related_groups
 *   Array of groups referenced by the node.
 *
 * @return
 *   String containing the related groups.
 */
function radar_og_related_groups_text($related_groups) {
  // In 1 group: "in the x group"
  if (count($related_groups) == 1) {
    return t(' in the !group group', array('!group' => l($related_groups[0]->title, 'node/' . $related_groups[0]->nid)));
  }

  // In 2 groups: "in the x and y groups"
  if (count($related_groups) == 2) {
    return t(' in the !group-0 and !group-1 groups', array(
      '!group-0' => l($related_groups[0]->title, 'node/' . $related_groups[0]->nid),
      '!group-1' => l($related_groups[1]->title, 'node/' . $related_groups[1]->nid),
    ));
  }

  // In more than 2 groups: "in the x, y and z groups"
  if (count($related_groups) > 2) {
    // Separate the last group.
    $last_group = array_pop($related_groups);
    $text = ' in the ';
    // Prepare tokens for t() for each of the other groups.
    foreach ($related_groups as $key => $this_group) {
      $text .= "!group-$key, ";
      $t_args["!group-$key"] = l($this_group->title, 'node/' . $this_group->nid);
    }
    // Prepare the last group token.
    $text .= " and !group-$last_group->nid groups.";
    $t_args["!group-$last_group->nid"] = l($last_group->title, 'node/' . $last_group->nid);
    // Prepare the full text with all of the groups and their tokens:
    return t($text, $t_args);
  }
}

function radar_og_group_submission_message($form, &$form_state) {
  if ($form_state['values']['status'] !== 1) {
    drupal_set_message(t('Thanks for your group submission! This group has entered the moderation queue and will be reviewed shortly.'));
  }
}


/**
 * Implements hook_strongarm_alter().
 */
function radar_og_strongarm_alter(&$items) {
  // Expose the Group content type for integration with Radar Radioactivity.
  if (isset($items['radar_radioactivity_entity_types'])) {
    $items['radar_radioactivity_entity_types']->value['node']['group'] = 1;
  }
}

function radar_og_default_rules_configuration_alter(&$configs) {
  // Disable default OG new content notifications.
  // The language doesn't correspond to Radar' open groups model and we use
  // radar_follow and radar_follow_notify for new content notifications.
  if (isset($configs['rules_og_member_active'])) {
    $configs['rules_og_member_active']->active = FALSE;
  }
}

/**
 * Implements hook_node_update().
 */
function radar_og_node_update($node) {
  if (og_is_group('node', $node)) {
    radar_og_set_group_permissions($node);
  }
}

/**
 * Implements hook_node_insert().
 */
function radar_og_node_insert($node) {
  if (og_is_group('node', $node)) {
    // When creating a new group, this hook happens before OG creates the
    // group specific roles. Therefore we create the roles here before altering
    // them in radar_og_set_group_permissions().
    og_roles_override('node', $node->type, $node->nid);
    radar_og_set_group_permissions($node);
  }
}

/**
 * Set the group's permissions according to field_og_subscribe_settings.
 *
 * @param $node
 *   A group node.
 */
function radar_og_set_group_permissions($node) {
  // Avoid updating a group subscription twice on the same request.
  $updated_nodes = & drupal_static(__FUNCTION__);
  if (!empty($updated_nodes[$node->nid])) {
    return;
  }
  $updated_nodes[$node->nid] = TRUE;

  $wrapper = entity_metadata_wrapper('node', $node);
  $permission = $wrapper->field_og_subscribe_settings->value();
  $og_roles = og_roles('node', $node->type, $node->nid);
  $anon_rid = array_search(OG_ANONYMOUS_ROLE, $og_roles);

  $permissions = array(
    'subscribe' => $permission == 'approval',
    'subscribe without approval' => $permission == 'anyone',
  );

  $group_content_entity_types = radar_og_get_group_content_entity_types();
  if (!empty($group_content_entity_types)) {
    foreach ($group_content_entity_types as $entity_type => $bundles) {
      // @todo other entity types permissions, how to query anon posting
      // generally?
      if ($entity_type == 'node') {
        foreach (array_keys($bundles) as $bundle) {
          $permissions["create $bundle content"] = $permission == 'anyone';
        }
      }
    }
  }

  // Check if the permissions needs to be changed.
  $changed = FALSE;
  $old_permissions = og_role_permissions(array($anon_rid => OG_ANONYMOUS_ROLE));
  foreach ($permissions as $permission => $value) {
    if (empty($old_permissions[$anon_rid][$permission]) || $old_permissions[$anon_rid][$permission] != $value) {
      $changed = TRUE;
    }
  }

  // Only change the permissions when neccessary.
  if ($changed) {
    og_role_change_permissions($anon_rid, $permissions);
  }
}

/**
 * Returns an array of entity types that are enabled via Radar Groups.
 */
function radar_og_get_group_content_entity_types() {
  // Find all Radar Entity integrations.
  $radar_entity_integrations = radar_entity_integration_info();
  if (empty($radar_entity_integrations)) {
    return array();
  }

  foreach ($radar_entity_integrations as $entity_type => $integration) {
    foreach ($integration as $bundle => $options) {
      if (isset($options['is_group_content']) && $options['is_group_content'] == FALSE) {
        unset($radar_entity_integrations[$entity_type][$bundle]);
      }
    }
    // If an entity type has no integrations, don't return it.
    if (empty($radar_entity_integrations[$entity_type])) {
      unset($radar_entity_integrations[$entity_type]);
    }
  }

  return $radar_entity_integrations;
}

/**
 * Returns an array of entity types that are defined as a group.
 */
function radar_og_get_group_types() {
  // Find all Radar Entity integrations.
  $radar_og = array();
  $radar_entity_integrations = radar_entity_integration_info();
  if (empty($radar_entity_integrations)) {
    return array();
  }

  foreach ($radar_entity_integrations as $entity_type => $integration) {
    foreach ($integration as $bundle => $options) {
      if (isset($options['is_group']) && $options['is_group'] == TRUE) {
        $radar_og[$entity_type][$bundle] = $radar_entity_integrations[$entity_type][$bundle];
      }
    }
  }

  return $radar_og;
}

/**
 * Implements hook_preprocess_node().
 */
function radar_og_preprocess_node(&$variables) {
  $variables['user_picture'] = '';
  if (variable_get('user_pictures', 0)) {
    $node = $variables['node'];
    $account = user_load($node->uid);

    if (!empty($account->picture)) {
      // @TODO: Ideally this function would only be passed file objects, but
      // since there's a lot of legacy code that JOINs the {users} table to
      // {node} or {comments} and passes the results into this function if we
      // a numeric value in the picture field we'll assume it's a file id
      // and load it for them. Once we've got user_load_multiple() and
      // comment_load_multiple() functions the user module will be able to load
      // the picture files in mass during the object's load process.
      if (is_numeric($account->picture)) {
        $account->picture = file_load($account->picture);
      }
      if (!empty($account->picture->uri)) {
        $filepath = $account->picture->uri;
      }
    }
    elseif (variable_get('user_picture_default', '')) {
      $filepath = variable_get('user_picture_default', '');
    }

    if (isset($filepath)) {
      if (module_exists('image') && file_valid_uri($filepath)) {
        $alt = t("@user's picture", array('@user' => format_username($account)));

        $render = array(
          '#theme' => 'image_formatter',
          '#image_style' => '50x50',
          '#item' => array(
            'uri' => $filepath,
            'alt' => $alt,
          ),
          '#path' => array(
            'path' => 'user/' . $account->uid,
            'options' => array(
              'attributes' => array(
                'title' => t("View @user's profile.", array('@user' => format_username($account))),
                'class' => array('user-picture'),
              ),
            ),
          ),
        );

        // Use a unique image style for user pictures in post information.
        $variables['user_picture'] = drupal_render($render);
      }
    }
  }
}

/**
 * Implements hook_preprocess_views_view_list().
 */
function radar_og_preprocess_views_view_list(&$variables, $hook) {
  // Change the displayed role name in the group contributors block to
  // "Organizers".
  if ($variables['view']->name == 'radar_contributors_group' && !empty($variables['title']) && $variables['title'] == 'administrator member') {
    $variables['title'] = t('Organizers');
  }
}

/**
 * Implements hook_field_access().
 */
function radar_og_field_access($op, $field, $entity_type, $entity, $account) {
  $field_name = $field['field_name'];
  switch ($field_name) {
    case 'og_roles_permissions':
      return FALSE;

    case 'field_og_access_default_value':
      return $op == 'edit' && module_exists('og_access');

    case 'field_og_subscribe_settings':
      return $op == 'edit';
  }

  if (module_exists('og_access') && in_array($field_name, array(OG_CONTENT_ACCESS_FIELD, OG_ACCESS_FIELD))) {
    return FALSE;
  }
}

/**
 * Implements hook_field_formatter_info().
 */
function radar_og_field_formatter_info() {
  return array(
    'radar_og_group_subscribe' => array(
      'label' => t('Radar groups subscribe link'),
      'field types' => array('list_boolean'),
      'settings' => array(
        'field_name' => FALSE,
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function radar_og_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  global $user;
  $account = clone $user;

  if ($display['type'] != 'radar_og_group_subscribe') {
    return;
  }

  if (!og_is_group($entity_type, $entity)) {
    return;
  }

  if (!empty($entity->uid) && ($entity->uid == $account->uid)) {
    // User is the group manager.
    $element[0] = array('#markup' => t('You are the group manager'));
    return $element;
  }

  list($id, , $bundle) = entity_extract_ids($entity_type, $entity);

  // The user has a pending membership request. Let her know that
  // her request is pending review.
  if (og_is_member($entity_type, $id, 'user', $account, array(OG_STATE_PENDING))) {
    $element[0] = array('#markup' => '<div class="subscription-type">' . t('Your membership request is pending review by a group organizer.') . '</div>');
    return $element;
  }
  // If user is blocked, they should not be able to apply for membership.
  if (og_is_member($entity_type, $id, 'user', $account, array(OG_STATE_BLOCKED))) {
    return;
  }
  if (og_is_member($entity_type, $id, 'user', $account)) {
    // The user has an active membership. She can leave the group.
    // For groups where anyone can contribute without joining, don't display
    // a "Leave" link since users never went through
    // the separate step of joining.
    if (og_is_member($entity_type, $id, 'user', $account, array(OG_STATE_ACTIVE)) && $entity->field_og_subscribe_settings[LANGUAGE_NONE][0]['value'] != 'anyone') {
      $links['title'] = t('Leave group');
      $links['href'] = "group/$entity_type/$id/unsubscribe";
    }
  }
  else {
    // Check if user can subscribe to the field.
    if (empty($settings['field_name']) && $audience_field_name = og_get_best_group_audience_field('user', $account, $entity_type, $bundle)) {
      $settings['field_name'] = $audience_field_name;
    }
    if (!$settings['field_name']) {
      return;
    }

    $field_info = field_info_field($settings['field_name']);

    // Check if entity is referencable.
    if ($field_info['settings']['target_type'] != $entity_type) {
      // Group type doesn't match.
      return;
    }
    if (!empty($field_info['settings']['handler_settings']['target_bundles']) && !in_array($bundle, $field_info['settings']['handler_settings']['target_bundles'])) {
      // Bundles don't match.
      return;
    }

    if (!og_check_field_cardinality('user', $account, $settings['field_name'])) {
      $element[0] = array('#markup' => format_plural($field_info['cardinality'], 'You are already registered to another group', 'You are already registered to @count groups'));
      return $element;
    }

    $url = "group/$entity_type/$id/subscribe";
    if ($settings['field_name']) {
      $url .= '/' . $settings['field_name'];
    }
    // Set the needs update hook if we end up with a group call that is missing
    // the subscribe settings. We also check the variable first, because we
    // don't want to reset the variable cache if we don't have to.
    // See https://drupal.org/node/2059857#comment-7733465 for more info.
    if (empty($entity->field_og_subscribe_settings)) {
      if (!variable_get('radar_og_needs_update', FALSE)) {
        variable_set('radar_og_needs_update', TRUE);
      }
    }
    // Don't display join link on public groups.
    else {
      if ($entity->field_og_subscribe_settings[LANGUAGE_NONE][0]['value'] != 'anyone') {
        if ($entity->field_og_subscribe_settings[LANGUAGE_NONE][0]['value'] == 'approval') {
          $subscription_type = t('Moderated group');
          $links['title'] = t('Join group');
          if ($account->uid) {
            $links['href'] = $url;
          }
          else {
            $links['href'] = 'user/login';
            $links['options'] = array('query' => array('destination' => $url));
          }
        }
        else {
          $element[0] = array('#markup' => '<div class="subscription-type">' . t('Invite-only group') . '</div>');
          return $element;
        }
      }
    }
  }
  if (!empty($links['title'])) {
    $links += array('options' => array());
    $element[0] = array(
      '#type' => 'link',
      '#title' => $links['title'],
      '#href' => $links['href'],
      '#options' => $links['options'],
    );

    if (!empty($subscription_type)) {
      $element[0]['#prefix'] = '<div class="subscription-type">' . $subscription_type . '</div>';
    }

    return $element;
  }
}

/**
 * Return a form element with crafted links to create nodes for a group.
 *
 * Tests users ability to create content in the group, and alters link text
 * appropriately.
 * @see og_node_create_links().
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group ID.
 * @param $field_name
 *   The group audience field name.
 * @param $destination
 *   (optional) The destiantion after a node is created. Defaults to the
 *   destination passed in the URL if exists, otherwise back to the current
 *   page. FALSE to not append any destination to node create links.
 * @param $types
 *   (optional) An array of type names. Restrict the created links to the given
 *   types.
 */
function radar_og_node_create_links($group_type, $gid, $field_name, $destination = NULL, $types = NULL) {
  if (!og_is_group($group_type, $gid)) {
    return;
  }

  $types = isset($types) ? $types : array_keys(node_type_get_types());
  foreach ($types as $type_name) {
    if (!og_is_group_content_type('node', $type_name)) {
      continue;
    }

    $instance = field_info_instance('node', $field_name, $type_name);
    if (empty($instance['settings']['behaviors']['prepopulate']['status'])) {
      // Instance doesn't allow prepopulating.
      continue;
    }
    $names[$type_name] = node_type_get_name($type_name);
  }

  if (empty($names)) {
    return;
  }

  // Sort names.
  asort($names);

  // Build links.
  $options  = array(
    'html' => TRUE,
    'query' => array($field_name => $gid),
  );

  if ($destination) {
    $options['query']['destination'] = $destination;
  }
  elseif ($destination !== FALSE) {
    $options['query'] += drupal_get_destination();
  }

  $items = array();
  foreach ($names as $type => $name) {
    // theme_item_list's 'data' items isn't a render element, so use l().
    // http://drupal.org/node/891112
    $permission = og_user_access('node', $gid, "Create $type content");
    $name = drupal_strtolower($name);
    $link_text = $permission ? t("Create new %name in group", array('%name' => $name)) : t("Submit new %name to group", array('%name' => $name));
    $items[] = array('data' => l($link_text, 'node/add/' . str_replace('_', '-', $type), $options));
  }

  $element = array();
  $element['og_node_create_links'] = array(
    '#theme' => 'item_list',
    '#items' => $items,
  );

  return $element;
}


/**
 * Special Radar implementation of hook_features_rebuild().
 *
 * By default, reverting og permissions only occurs on the default rid, which is
 * 0. All groups already created will not see the new permissions.
 *
 * As an alternative, this function iterates through all of the groups and sets
 * default permissions and update the permissions map.
 *
 * @param string $module
 *   The modules whose default user permissions should be rebuild.
 */
function radar_og_features_permission_rebuild($module, $gid) {
  module_load_include('features.inc', 'og', '/includes/og_features_role');

  if ($defaults = features_get_default('og_features_permission', $module)) {
    $grant = array();
    $revoke = array();

    foreach ($defaults as $key => $details) {
      list($group_type, $bundle, $perm) = explode(':', $key);

      // Make sure the role exists for this entity.
      foreach ($details['roles'] as $role) {
        $bundle_role = _og_features_role_exists($role, $group_type, $bundle);
        if (empty($bundle_role)) {
          og_role_save(og_role_create($role, $group_type, $gid, $bundle));
        }
      }

      $roles = og_roles($group_type, $bundle, $gid);
      foreach ($roles as $rid => $rolename) {
        if (in_array($rolename, $details['roles'])) {
          $grant[$rid][] = $perm;
        }
        else {
          $revoke[$rid][] = $perm;
        }
      }
    }

    if (!empty($grant)) {
      foreach ($grant as $rid => $permissions) {
        og_role_grant_permissions($rid, $permissions);
      }
    }

    if (!empty($revoke)) {
      foreach ($revoke as $rid => $permissions) {
        og_role_revoke_permissions($rid, $permissions);
      }
    }
  }
}
